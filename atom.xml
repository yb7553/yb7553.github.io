<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>码农的春天</title>
  
  <subtitle>好的架构是码农的春天，不用加班、有时间泡妞</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-11-28T04:58:45.935Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>严彬</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微服务高可用</title>
    <link href="http://yoursite.com/2018/11/28/spring-cloud-ha/"/>
    <id>http://yoursite.com/2018/11/28/spring-cloud-ha/</id>
    <published>2018-11-28T04:55:03.000Z</published>
    <updated>2018-11-28T04:58:45.935Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5189695-9db6a584bacc7efa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5189695-9db6a584bacc7efa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>BI数据架构</title>
    <link href="http://yoursite.com/2018/11/28/bi/"/>
    <id>http://yoursite.com/2018/11/28/bi/</id>
    <published>2018-11-28T03:13:58.000Z</published>
    <updated>2018-11-28T03:14:47.098Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5189695-4591d567c4b177e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5189695-4591d567c4b177e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>spring cloud微服务</title>
    <link href="http://yoursite.com/2018/11/28/spring-cloud/"/>
    <id>http://yoursite.com/2018/11/28/spring-cloud/</id>
    <published>2018-11-28T02:37:21.000Z</published>
    <updated>2018-11-28T03:04:05.442Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5189695-fb5af178b28c633a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><p>Spring Cloud包含多个子项目，Spring Cloud Config（可扩展配置服务）、Spring Cloud Netflix、Spring Cloud CloudFoundry（开源PaaS云平台）、Spring Cloud AWS（亚马逊云服务平台）、Spring Cloud Security、Spring Cloud Commons、spring Cloud Zookeeper、Spring Cloud CLI等项目。</p><h2 id="一、服务注册中心"><a href="#一、服务注册中心" class="headerlink" title="一、服务注册中心"></a>一、服务注册中心</h2><p>1、eureka服务注册中心</p><pre><code> Spring Cloud Eureka是Spring Cloud Netflix项目下的服务治理模块。而Spring Cloud Netflix项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路由（Zuul），客户端负载均衡（Ribbon）等。创建服务注册中心eureka-server，引入eureka依赖：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;Dalston.SR1&lt;/version&gt;</span><br><span class="line">           &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">           &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure><p>通过@EnableEurekaServer注解启动一个服务注册中心提供给其他应用进行对话。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@EnableEurekaServer</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line"> </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在默认设置下，该服务注册中心也会将自己作为客户端来尝试注册它自己，所以我们需要禁用它的客户端注册行为，只需要在application.properties配置文件中增加如下信息：</p><p>#应用名<br>spring.application.name=eureka-server</p><p>#tomcat监听端口<br>server.port=1001</p><p>#eureka主机地址<br>eureka.instance.hostname=localhost</p><p>#禁用eureka客户端的注册行为<br>eureka.client.register-with-eureka=false</p><p>#如果为true，启动时报警.<br>eureka.client.fetch-registry=false<br>在<a href="http://127.0.0.1:1001/" target="_blank" rel="noopener">http://127.0.0.1:1001/</a> 可看到eureka的服务管理页面</p><p> 2、Consul服务治理</p><pre><code>Spring Cloud Consul项目是针对Consul的服务治理实现。Consul是一个分布式高可用的系统，它包含多个组件，但是作为一个整体，在微服务架构中为我们的基础设施提供服务发现和服务配置的工具。它包含了下面几个特性：</code></pre><p>服务发现<br>健康检查<br>Key/Value存储<br>多数据中心<br>    Consul自身提供了服务端，所以我们不需要像之前实现Eureka的时候创建服务注册中心，直接通过下载consul的服务端程序就可以使用。</p><p>   consul服务器启动命令：</p><p>consul agent -dev<br>服务管理界面：<a href="http://127.0.0.1:8500" target="_blank" rel="noopener">http://127.0.0.1:8500</a></p><h2 id="二、服务提供方"><a href="#二、服务提供方" class="headerlink" title="二、服务提供方"></a>二、服务提供方</h2><p>1、向eureka注册</p><pre><code> 服务的客户端，并向服务注册中心注册自己创建一个基本的Spring Boot应用。命名为eureka-client，在pom.xml中，加入如下配置：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt; </span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;Dalston.SR1&lt;/version&gt;</span><br><span class="line">           &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">           &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure><p>   配置文件配置：</p><p>#指定微服务的名称后续在调用的时候只需要使用该名称就可以进行服务的访问<br>spring.application.name=eureka-client</p><p>#修改tomcat端口为2001<br>server.port=2001</p><p>#指定服务注册中心的位置<br>eureka.client.serviceUrl.defaultZone=<a href="http://localhost:1001/eureka/" target="_blank" rel="noopener">http://localhost:1001/eureka/</a></p><p>并在服务提供方中尝试着提供一个接口来获取当前所有的服务信息。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class DcController &#123;</span><br><span class="line"></span><br><span class="line">private final Logger log=Logger.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">@Autowired</span><br><span class="line">private DiscoveryClient discoveryClient;//通过DiscoveryClient对象，在日志中打印出服务实例的相关内容。</span><br><span class="line">    </span><br><span class="line">@RequestMapping(value=&quot;/dc&quot;)</span><br><span class="line">public String dc()&#123;</span><br><span class="line">String services=&quot;eclipse services:&quot;+discoveryClient.getServices();</span><br><span class="line">log.info(services);</span><br><span class="line">return services;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后在应用主类中通过加上@EnableDiscoveryClient注解，该注解能激活Eureka中的DiscoveryClient实现，这样才能实现Controller中对服务信息的输出。<br>@EnableEurekaClient<br>@SpringBootApplication<br>public class Application {</p><pre><code>public static void main(String[] args) {    new SpringApplicationBuilder(Application.class).web(true).run(args);}</code></pre><p>}</p><p>2、向consul注册</p><p> 接口和之前一样，只要改变依赖和配置信息就行</p><p>   添加Spring Cloud Consul依赖如下：</p><p><dependency><br>  <groupid>org.springframework.cloud</groupid><br>  <artifactid>spring-cloud-starter-consul-discovery</artifactid><br></dependency><br>修改application.properties配置文件如下：</p><p>#consul服务注册与发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.application.name=consul-client</span><br><span class="line">spring.cloud.consul.host=127.0.0.1</span><br><span class="line">spring.cloud.consul.port=8500</span><br></pre></td></tr></table></figure><h2 id="三、服务消费方"><a href="#三、服务消费方" class="headerlink" title="三、服务消费方"></a>三、服务消费方</h2><p>1、使用Spring Cloud提供的负载均衡器客户端接口LoadBalancerClient来实现服务的消费</p><p>创建一个服务消费者工程，命名为：eureka-consumer。并在pom.xml中引入依赖:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt; </span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.3.1.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  </span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.8.1&lt;/version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>配置application.properties，指定eureka注册中心的地址：</p><p>spring.application.name=eureka-consumers<br>server.port=2101</p><p>#服务注册中心地址<br>eureka.client.serviceUrl.defaultZone=<a href="http://localhost:1001/eureka/" target="_blank" rel="noopener">http://localhost:1001/eureka/</a><br>创建应用主类。初始化RestTemplate，用来真正发起REST请求。@EnableDiscoveryClient注解用来将当前应用加入到服务治理体系中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@EnableDiscoveryClient//注解用来将当前应用加入到服务治理体系中。</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line"> </span><br><span class="line">@Bean</span><br><span class="line">public RestTemplate restTemplate()&#123;</span><br><span class="line">return new RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建一个接口用来消费eureka-client提供的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class DcController &#123;</span><br><span class="line"> </span><br><span class="line">@Autowired</span><br><span class="line">private RestTemplate restTemplate;//利用RestTemplate对象实现对服务提供者接口的调用</span><br><span class="line">@Autowired </span><br><span class="line">private LoadBalancerClient loadBalancerClient;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;/consumer&quot;)//注解get请求</span><br><span class="line">public String dc()&#123;</span><br><span class="line">//通过loadBalancerClient的choose负载均衡的选出一个eureka-client的服务实例</span><br><span class="line">ServiceInstance serviceInstance=loadBalancerClient.choose(&quot;eureka-client&quot;);</span><br><span class="line">String url=&quot;http://&quot;+serviceInstance.getHost()+&quot;:&quot;+serviceInstance.getPort()+&quot;/dc&quot;;</span><br><span class="line">System.out.println(url);</span><br><span class="line">return restTemplate.getForObject(url, String.class);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>可以看到这里，我们注入了LoadBalancerClient和RestTemplate，并在/consumer接口的实现中，先通过loadBalancerClient的choose函数来负载均衡的选出一个eureka-client的服务实例，这个服务实例的基本信息存储在ServiceInstance中，然后通过这些对象中的信息拼接出访问/dc接口的详细地址，最后再利用RestTemplate对象实现对服务提供者接口的调用。</code></pre><p>2、Spring Cloud Ribbon</p><pre><code>Spring Cloud Ribbon是基于Netflix Ribbon实现的一套客户端负载均衡的工具。它是一个基于HTTP和TCP的客户端负载均衡器。它可以通过在客户端中配置ribbonServerList来设置服务端列表去轮询访问以达到均衡负载的作用。</code></pre><p>导入依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt; </span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.3.1.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">   </span><br><span class="line">    &lt;!-- 负载均衡的工具 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.3.1.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>application.properties配置文件的配置不变，还是从eureka中拿服务。<br>修改应用主类。为RestTemplate增加@LoadBalanced注解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line"> </span><br><span class="line">@Bean</span><br><span class="line">@LoadBalanced</span><br><span class="line">public RestTemplate restTemplate()&#123;</span><br><span class="line">return new RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改Controller。去掉原来通过LoadBalancerClient选取实例和拼接URL的步骤，直接通过RestTemplate发起请求。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class DcController &#123;</span><br><span class="line"> </span><br><span class="line">@Autowired</span><br><span class="line">private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;/consumer&quot;)</span><br><span class="line">public String dc()&#123;</span><br><span class="line">return restTemplate.getForObject(&quot;http://eureka-client/dc&quot;, String.class);</span><br><span class="line">&#125;</span><br><span class="line">/*</span><br><span class="line"> * Spring Cloud Ribbon有一个拦截器，它能够在这里进行实际调用的时候，自动的去选取服务实例，</span><br><span class="line"> * 并将实际要请求的IP地址和端口替换这里的服务名，从而完成服务接口的调用。</span><br><span class="line"> */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、Spring Cloud Feign<br>       Spring Cloud Feign是一套基于Netflix Feign实现的声明式服务调用客户端。它使得编写Web服务客户端变得更加简单。我们只需要通过创建接口并用注解来配置它既可完成对Web服务接口的绑定。它具备可插拔的注解支持，包括Feign注解、JAX-RS注解。它也支持可插拔的编码器和解码器。Spring Cloud Feign还扩展了对Spring MVC注解的支持，同时还整合了Ribbon和Eureka来提供均衡负载的HTTP客户端实现。</p><p>pom.xml中的依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt; </span><br><span class="line"> </span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.3.1.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-feign&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.3.1.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">  &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><p>修改应用主类。通过@EnableFeignClients注解开启扫描Spring Cloud Feign客户端的功能：</p><p>@EnableFeignClients//注解开启扫描Spring Cloud Feign客户端的功能<br>@EnableDiscoveryClient<br>@SpringBootApplication<br>public class Application {</p><pre><code>public static void main(String[] args) {    new SpringApplicationBuilder(Application.class).web(true).run(args);}</code></pre><p>}</p><p>创建一个Feign的客户端接口定义。使用@FeignClient注解来指定这个接口所要调用的服务名称，接口中定义的各个函数使用Spring MVC的注解就可以来绑定服务提供方的REST接口，比如下面就是绑定eureka-client服务的/dc接口的例子：</p><p>/*</p><ul><li><p>通过@FeignClient定义的接口来统一的生成我们需要依赖的微服务接口。而在具体使用的时候就跟调用本地方法一点的进行调用即可<br>*/<br>@FeignClient(“eureka-client”)//使用@FeignClient注解来指定这个接口所要调用的服务名称<br>public interface DcClient {</p><p> @GetMapping(“/dc”)//接口中定义的各个函数使用Spring MVC的注解就可以来绑定服务提供方的REST接口<br> public String consumer();<br>}</p></li></ul><p>修改Controller。通过定义的feign客户端来调用服务提供方的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class DcController &#123;</span><br><span class="line"> </span><br><span class="line">@Autowired</span><br><span class="line">private DcClient dcClient;</span><br><span class="line"></span><br><span class="line">@GetMapping(&quot;/consumer&quot;)</span><br><span class="line">public String consumer()&#123;</span><br><span class="line">return dcClient.consumer();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、配置中心"><a href="#四、配置中心" class="headerlink" title="四、配置中心"></a>四、配置中心</h2><pre><code>Spring Cloud Config为服务端和客户端提供了分布式系统的外部化配置支持。配置服务器为各应用的所有环境提供了一个中心化的外部配置。配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理，并且可以通过git客户端工具来方便的管理和访问配置内容。</code></pre><p>1、构建服务端Config-Server</p><pre><code>pom.xml中引入spring-cloud-config-server依赖，完整依赖配置如下：</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.4.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;relativePath/&gt;</span><br><span class="line">  &lt;/parent&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;!-- config-server也注册为服务，这样所有客户端就能以服务的方式进行访问 --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    </span><br><span class="line">  &lt;/dependencies&gt;</span><br><span class="line">  &lt;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;Brixton.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure><p>application.properties中配置服务信息以及git信息，例如：</p><p>#服务器应用名<br>spring.application.name=config-server</p><p>#远程仓库地址<br>spring.cloud.config.server.git.uri=<a href="https://github.com/jlzl123/config-repo-demo.git" target="_blank" rel="noopener">https://github.com/jlzl123/config-repo-demo.git</a><br>spring.cloud.config.server.git.username=jlzl123<br>spring.cloud.config.server.git.password=<strong>***</strong></p><p>server.port:1201</p><p>#eureka注册中心配置<br>eureka.client.serviceUrl.defaultZone=<a href="http://localhost:1001/eureka/" target="_blank" rel="noopener">http://localhost:1001/eureka/</a><br>spring.cloud.config.server.git.uri是git远程配置文件仓库地址</p><p>创建Spring Boot的程序主类，并添加@EnableConfigServer注解，开启Config Server:</p><p>package org.config.server.git;</p><p>import org.springframework.boot.autoconfigure.SpringBootApplication;<br>import org.springframework.boot.builder.SpringApplicationBuilder;<br>import org.springframework.cloud.client.discovery.EnableDiscoveryClient;<br>import org.springframework.cloud.config.server.EnableConfigServer;</p><p>@EnableDiscoveryClient//用来将config-server注册到上面配置的服务注册中心上去。<br>@EnableConfigServer//开启Spring Cloud Config的服务端功能。<br>@SpringBootApplication<br>public class Application {</p><pre><code>public static void main(String[] args) {    new SpringApplicationBuilder(Application.class).web(true).run(args);}</code></pre><p>}</p><p>Spring Cloud Config也提供本地存储配置的方式。我们只需要设置属性spring.profiles.active=native，Config Server会默认从应用的src/main/resource目录下检索配置文件。也可以通过spring.cloud.config.server.native.searchLocations=file:F:/properties/属性来指定配置文件的位置。虽然Spring Cloud Config提供了这样的功能，但是为了支持更好的管理内容和版本控制的功能，还是推荐使用git的方式。</p><p>完成上面后我们就可以通过URL访问远程配置信息了：</p><p><a href="http://localhost:1201/config-client-dev/dev/master" target="_blank" rel="noopener">http://localhost:1201/config-client-dev/dev/master</a></p><p>URL与配置文件的映射关系如下：<br>/{application}/{profile}[/{label}]<br>/{application}-{profile}.yml<br>/{label}/{application}-{profile}.yml<br>/{application}-{profile}.properties<br>/{label}/{application}-{profile}.properties<br>上面的url会映射{application}-{profile}.properties对应的配置文件，{label}对应git上不同的分支，默认为master。profile是配置文件对应的不同开发环境。<br>比如：要访问config-label-test分支，didispace应用的prod环境，可以通过这个url：<a href="http://localhost:7001/didispace/prod/config-label-test。" target="_blank" rel="noopener">http://localhost:7001/didispace/prod/config-label-test。</a></p><p>2、构建客户端config-client</p><p>pom.xml中引入spring-cloud-starter-config依赖，完整依赖关系如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;exclusions&gt;&lt;!-- 排除对[spring-boot-starter-logging]的依赖，解决log4j依赖jar包冲突 --&gt;</span><br><span class="line">&lt;exclusion&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">&lt;/exclusion&gt;</span><br><span class="line">&lt;/exclusions&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">&lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-starter-log4j&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.3.8.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;Brixton.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">&lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br><span class="line">     </span><br><span class="line">    &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。--&gt;</span><br><span class="line">&lt;repositories&gt;</span><br><span class="line">&lt;repository&gt;</span><br><span class="line">&lt;id&gt;spring-milestones&lt;/id&gt;</span><br><span class="line">&lt;name&gt;Spring Milestones&lt;/name&gt;</span><br><span class="line">&lt;url&gt;https://repo.spring.io/milestone&lt;/url&gt;</span><br><span class="line">&lt;snapshots&gt;</span><br><span class="line">&lt;enabled&gt;false&lt;/enabled&gt;</span><br><span class="line">&lt;/snapshots&gt;</span><br><span class="line">&lt;/repository&gt;</span><br><span class="line">&lt;/repositories&gt;</span><br></pre></td></tr></table></figure><p>创建Spring Boot启动主类，并利用@EnableDiscoveryClient注解将客户端以服务的形式注册到eureka再服务注册中心。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package org.config.client;</span><br><span class="line"> </span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line">import org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line"> </span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line"> </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建bootstrap.properties配置，来指定config server，例如：</p><p>#远程配置仓库配置文件名<br>spring.application.name=config-client-dev,test,config-test,datasource</p><p>#配置中心服务器地址<br>spring.cloud.config.uri=<a href="http://localhost:1201/" target="_blank" rel="noopener">http://localhost:1201/</a></p><p>#当前配置环境，相同配置文件的不同环境，通过profile区分<br>spring.cloud.config.profile=dev</p><p>#git仓库分支，默认为master<br>spring.cloud.config.label=master<br>server.port=2003</p><p>#git的yml配置文件的格式好象有问题，最好用properties</p><p>#eureka注册中心配置<br>eureka.client.serviceUrl.defaultZone=<a href="http://localhost:1001/eureka/" target="_blank" rel="noopener">http://localhost:1001/eureka/</a></p><p>这里需要格外注意：上面这些属性必须配置在bootstrap.properties中，config部分内容才能被正确加载。因为config的相关配置会先于application.properties，而bootstrap.properties的加载也是先于application.properties。<br>即配置客户端启动，先加载bootstrap.properties配置文件,然后从远程配置仓库获取配置，所以这些配置会优于application.properties的配置被容器加载，即远程仓库的配置会覆盖掉application的配置。这样，就可以直接把项目配置文件写在远程仓库。</p><p>注意，springboot并不加载bootstrap.properties，只用config client的jar封装ConfigServerBootstrapConfiguration先加bootstrap.properties。</p><p>创建一个Rest Api来返回配置中心的from属性，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@RefreshScope</span><br><span class="line">@RestController</span><br><span class="line">class TestController &#123;</span><br><span class="line">    @Value(&quot;$&#123;from&#125;&quot;)</span><br><span class="line">    private String from;</span><br><span class="line">    @RequestMapping(&quot;/from&quot;)</span><br><span class="line">    public String from() &#123;</span><br><span class="line">        return this.from;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以通过@ConfigurationProperties注解来绑定配置属性，创建如下配置类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package org.config.client.dataSourceConfig;</span><br><span class="line"> </span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"> </span><br><span class="line">@Configuration</span><br><span class="line">//@ConfigurationProperties注解绑定属性,prefix为属性名的前缀，如:jdbc.url</span><br><span class="line">@ConfigurationProperties(prefix=&quot;jdbc&quot;,ignoreUnknownFields=false)</span><br><span class="line">public class DataSourceProperties &#123;</span><br><span class="line"> </span><br><span class="line">private String driver;</span><br><span class="line">private String url;</span><br><span class="line">private String username;</span><br><span class="line">private String password;</span><br><span class="line"></span><br><span class="line">public String getDriver() &#123;</span><br><span class="line">return driver;</span><br><span class="line">&#125;</span><br><span class="line">public void setDriver(String driver) &#123;</span><br><span class="line">this.driver = driver;</span><br><span class="line">&#125;</span><br><span class="line">public String getUrl() &#123;</span><br><span class="line">return url;</span><br><span class="line">&#125;</span><br><span class="line">public void setUrl(String url) &#123;</span><br><span class="line">this.url = url;</span><br><span class="line">&#125;</span><br><span class="line">public String getUsername() &#123;</span><br><span class="line">return username;</span><br><span class="line">&#125;</span><br><span class="line">public void setUsername(String username) &#123;</span><br><span class="line">this.username = username;</span><br><span class="line">&#125;</span><br><span class="line">public String getPassword() &#123;</span><br><span class="line">return password;</span><br><span class="line">&#125;</span><br><span class="line">public void setPassword(String password) &#123;</span><br><span class="line">this.password = password;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="五、断路器"><a href="#五、断路器" class="headerlink" title="五、断路器"></a>五、断路器</h2><pre><code>在分布式架构中，当某个服务单元发生故障（类似用电器发生短路）之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个错误响应，而不是长时间的等待。这样就不会使得线程因调用故障服务被长时间占用不释放，避免了故障在分布式系统中的蔓延。在Spring Cloud中使用了Hystrix 来实现断路器的功能。Hystrix是Netflix开源的微服务框架套件之一，该框架目标在于通过控制那些访问远程系统、服务和第三方库的节点，从而对延迟和故障提供更强大的容错能力。Hystrix具备拥有回退机制和断路器功能的线程和信号隔离，请求缓存和请求打包，以及监控和配置等功能。</code></pre><p>1、eureka-consumer-ribbon添加断路器</p><p>pom.xml中引入依赖hystrix依赖:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.3.1.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>在eureka-consumer-ribbon的主类Application中使用@EnableCircuitBreaker注解开启断路器功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package org.eureka.consumer.ribbon;</span><br><span class="line"> </span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line">import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;</span><br><span class="line">import org.springframework.cloud.client.discovery.EnableDiscoveryClient;</span><br><span class="line">import org.springframework.cloud.client.loadbalancer.LoadBalanced;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line"> </span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableCircuitBreaker//@EnableCircuitBreaker注解开启断路器功能</span><br><span class="line">public class Application &#123;</span><br><span class="line"> </span><br><span class="line">@Bean</span><br><span class="line">@LoadBalanced//加载负载均衡</span><br><span class="line">public RestTemplate restTemplate()&#123;</span><br><span class="line">return new RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new SpringApplicationBuilder(Application.class).web(true).run(args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改造原来的服务消费方式，新增ComputeService类，在使用ribbon消费服务的函数上增加@HystrixCommand注解来指定回调方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package org.eureka.consumer.ribbon.service;</span><br><span class="line"> </span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.web.client.RestTemplate;</span><br><span class="line">import com.netflix.hystrix.contrib.javanica.annotation.HystrixCommand;</span><br><span class="line"> </span><br><span class="line">@Service</span><br><span class="line">public class ComputeService &#123;</span><br><span class="line"> </span><br><span class="line">@Autowired</span><br><span class="line">private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">//注解实现断路器回调，当调用服务失败后，调用addServiceFallback方法</span><br><span class="line">@HystrixCommand(fallbackMethod=&quot;addServiceFallback&quot;)</span><br><span class="line">public String addService()&#123;</span><br><span class="line">return restTemplate.getForObject(&quot;http://eureka-client/add?a=10&amp;b=20&quot;, String.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unused&quot;)</span><br><span class="line">private String addServiceFallback()&#123;</span><br><span class="line">return &quot;error&quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>提供rest接口的Controller改为调用ComputeService的addService<br>    @RequestMapping(value=”/addService”,method=RequestMethod.GET)<br>    public String addService(){<br>        return computeService.addService();<br>    }<br>这样添加断路器后，调用/addService接口服务，当服务提供者断线或获取服务超时，会调用fallback。</p><p>2、eureka-consumer-feign</p><p>fegin集成了hystrix断路器，只要在配置文件中配置下面参数开启就可以了，不用导入hystrix依赖。</p><p>feign.hystrix.enabled=true</p><p>使用@FeignClient注解中的fallback属性指定回调类：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package org.eureka.consumer.feign.service;</span><br><span class="line"> </span><br><span class="line">import org.eureka.consumer.feign.fallback.DcClientHystrix;</span><br><span class="line">import org.springframework.cloud.netflix.feign.FeignClient;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">/*</span><br><span class="line"> * 通过@FeignClient定义的接口来统一的生成我们需要依赖的微服务接口。而在具体使用的时候就跟调用本地方法一点的进行调用即可</span><br><span class="line"> */</span><br><span class="line">//使用@FeignClient注解来指定这个接口所要调用的服务名称,如过开启了断路器，通过fallback参数指定熔断后的回调类，该回调类实现当前接口</span><br><span class="line">@FeignClient(value=&quot;eureka-client&quot;,fallback=DcClientHystrix.class)</span><br><span class="line">public interface DcClient &#123;</span><br><span class="line"> </span><br><span class="line">@GetMapping(&quot;/dc&quot;)//接口中定义的各个函数使用Spring MVC的注解就可以来绑定服务提供方的REST接口</span><br><span class="line">public String consumer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建回调类ComputeClientHystrix，实现@FeignClient的接口，此时实现的方法就是对应@FeignClient接口中映射的fallback函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package org.eureka.consumer.feign.fallback;</span><br><span class="line"> </span><br><span class="line">import org.eureka.consumer.feign.service.DcClient;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"> * 回调类，实现@FeignClient的接口，此时实现的方法就是对应@FeignClient接口中映射的fallback函数。</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">public class DcClientHystrix implements DcClient&#123;</span><br><span class="line"> </span><br><span class="line">@Override</span><br><span class="line">public String consumer() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return &quot;调用失败，执行回调函数&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="六、服务网关"><a href="#六、服务网关" class="headerlink" title="六、服务网关"></a>六、服务网关</h2><pre><code>服务网关对微服务架构的作用：</code></pre><p>不仅仅实现了路由功能来屏蔽诸多服务细节，更实现了服务级别、均衡负载的路由。<br>实现了接口权限校验与微服务业务逻辑的解耦。通过服务网关中的过滤器，在各生命周期中去校验请求的内容，将原本在对外服务层做的校验前移，保证了微服务的无状态性，同时降低了微服务的测试难度，让服务本身更集中关注业务逻辑的处理。<br>实现了断路器，不会因为具体微服务的故障而导致服务网关的阻塞，依然可以对外服务。</p><p>使用Spring Cloud Netflix中的Zuul做服务网关，引入依赖spring-cloud-starter-zuul、spring-cloud-starter-eureka，如果不是通过指定serviceId的方式，eureka依赖不需要，但是为了对服务集群细节的透明性，还是用serviceId来避免直接引用url的方式吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">应用主类使用@EnableZuulProxy注解开启Zuul</span><br><span class="line"></span><br><span class="line">package org.api.gateway;</span><br><span class="line"> </span><br><span class="line">import org.springframework.boot.builder.SpringApplicationBuilder;</span><br><span class="line">import org.springframework.cloud.client.SpringCloudApplication;</span><br><span class="line">import org.springframework.cloud.netflix.zuul.EnableZuulProxy;</span><br><span class="line"> </span><br><span class="line">@EnableZuulProxy//注解开启Zuul服务网关</span><br><span class="line">@SpringCloudApplication//它整合了@SpringBootApplication、@EnableDiscoveryClient、@EnableCircuitBreaker等</span><br><span class="line">public class GatewayApplication &#123;</span><br><span class="line"> </span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">new SpringApplicationBuilder(GatewayApplication.class).web(true).run(args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>application.properties配置文件配置：</p><p>spring.application.name=api-gateway<br>server.port=5555</p><p>#配置注册服务中心地址，如果下面路由不用serviceId就不用配置，也不用导入eureka依赖<br>eureka.client.serviceUrl.defaultZone=<a href="http://localhost:1001/eureka/" target="_blank" rel="noopener">http://localhost:1001/eureka/</a></p><p>#路由配置</p><p>#配置属性zuul.routes.api-a-url.path中的api-a-url部分为路由的名字，可以任意定义.<br>zuul.routes.api-a.path=/eureka-client/**<br>zuul.routes.api-a.url=<a href="http://127.0.0.1:2001/" target="_blank" rel="noopener">http://127.0.0.1:2001/</a></p><p>zuul.routes.ribbon.path=/ribbon/**<br>zuul.routes.ribbon.serviceId=eureka-ribbon-consumer</p><p>zuul.routes.api-b.path=/feign/**<br>zuul.routes.api-b.serviceId=eureka-feign-consumer</p><p>这样/api-a/**的访问都映射到<a href="http://localhost:2001/上，也就是说当我们访问http://localhost:5555/api-a/add?a=1&amp;b=2的时候，Zuul会将该请求路由到：http://localhost:2222/add?a=1&amp;b=2上。" target="_blank" rel="noopener">http://localhost:2001/上，也就是说当我们访问http://localhost:5555/api-a/add?a=1&amp;b=2的时候，Zuul会将该请求路由到：http://localhost:2222/add?a=1&amp;b=2上。</a></p><pre><code>服务网关还可以做服务过滤，在完成了服务路由之后，我们对外开放服务还需要一些安全措施来保护客户端只能访问它应该访问到的资源。所以我们需要利用Zuul的过滤器来实现我们对外服务的安全控制。在服务网关中定义过滤器只需要继承ZuulFilter抽象类实现其定义的四个抽象函数就可对请求进行拦截与过滤。</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">package org.api.gateway.filter;</span><br><span class="line"> </span><br><span class="line">import javax.servlet.http.HttpServletRequest;</span><br><span class="line"> </span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"> </span><br><span class="line">import com.netflix.zuul.ZuulFilter;</span><br><span class="line">import com.netflix.zuul.context.RequestContext;</span><br><span class="line"> </span><br><span class="line">@Component//需要实例化该过滤器</span><br><span class="line">public class AccessFilter extends ZuulFilter&#123;</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"> * shouldFilter：返回一个boolean类型来判断该过滤器是否要执行</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public boolean shouldFilter() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return true;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"> * filterOrder：通过int值来定义过滤器的执行顺序</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public int filterOrder() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"> * filterType:返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：   </span><br><span class="line">             pre：可以在请求被路由之前调用</span><br><span class="line">             routing：在路由请求时候被调用</span><br><span class="line">             post：在routing和error过滤器之后被调用</span><br><span class="line">             error：处理请求时发生错误时被调用</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public String filterType() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">return &quot;pre&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">/*</span><br><span class="line"> * run：过滤器的具体逻辑。</span><br><span class="line"> */</span><br><span class="line">@Override</span><br><span class="line">public Object run() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">RequestContext ctx=RequestContext.getCurrentContext();</span><br><span class="line">HttpServletRequest request=ctx.getRequest();</span><br><span class="line">String token=request.getParameter(&quot;token&quot;);</span><br><span class="line">if(token==null)&#123;</span><br><span class="line">ctx.setSendZuulResponse(false);</span><br><span class="line">//ctx.getResponse().setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">//设置浏览器解码</span><br><span class="line">ctx.getResponse().setContentType(&quot;text/html;charset=utf-8&quot;);</span><br><span class="line">ctx.setResponseBody(&quot;非法访问!!&quot;);</span><br><span class="line">ctx.setResponseStatusCode(401);</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5189695-fb5af178b28c633a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>devops最佳实践</title>
    <link href="http://yoursite.com/2018/11/28/devops-1/"/>
    <id>http://yoursite.com/2018/11/28/devops-1/</id>
    <published>2018-11-28T02:21:13.000Z</published>
    <updated>2018-11-28T02:26:07.842Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5189695-a87aa3812e76ab4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5189695-a87aa3812e76ab4f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>docker基础架构</title>
    <link href="http://yoursite.com/2018/11/28/devops/"/>
    <id>http://yoursite.com/2018/11/28/devops/</id>
    <published>2018-11-28T02:11:49.592Z</published>
    <updated>2018-11-28T02:12:12.728Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5189695-0f77a07c50f709a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="一、docker基础概念"><a href="#一、docker基础概念" class="headerlink" title="一、docker基础概念"></a>一、docker基础概念</h2><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。</p><h4 id="1、Docker有以下几个部分组成："><a href="#1、Docker有以下几个部分组成：" class="headerlink" title="1、Docker有以下几个部分组成："></a>1、Docker有以下几个部分组成：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- Client客户端</span><br><span class="line">- Docker Daemon守护进程</span><br><span class="line">- Docker Image镜像</span><br><span class="line">- DockerContainer容器</span><br><span class="line">- Registry镜像仓库</span><br></pre></td></tr></table></figure><h4 id="2、Docker的三大核心概念：镜像、容器、仓库"><a href="#2、Docker的三大核心概念：镜像、容器、仓库" class="headerlink" title="2、Docker的三大核心概念：镜像、容器、仓库"></a>2、Docker的三大核心概念：镜像、容器、仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 镜像：类似虚拟机的镜像、用俗话说就是安装文件。</span><br><span class="line">- 容器：类似一个轻量级的沙箱，容器是从镜像创建应用运行实例，</span><br><span class="line">-       可以将其启动、开始、停止、删除、而这些容器都是相互隔离、互不可见的。</span><br><span class="line">- 仓库：类似代码仓库，是Docker集中存放镜像文件的场所。</span><br></pre></td></tr></table></figure><p>Docker采用 C/S架构 Docker daemon 作为服务端接受来自客户的请求，<br>并处理这些请求（创建、运行、分发容器）。<br>客户端和服务端既可以运行在一个机器上，也可通过 socket 或者RESTful API 来进行通信。</p><h2 id="二-docker安装"><a href="#二-docker安装" class="headerlink" title="二.docker安装"></a>二.docker安装</h2><p>linux系统环境 ，同时需要注意Linux系统必须能够上网,虚拟机使用桥接模式<br>建议使用centos7版本安装docker，docker容器需要镜像文件容器与镜像文件的关系就类似于类与对象的关系。</p><h2 id="三-docker安装步骤"><a href="#三-docker安装步骤" class="headerlink" title="三.docker安装步骤"></a>三.docker安装步骤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、使用yum命令在线安装:yum install docker</span><br><span class="line">2、查看docker的版本命令:docker -v</span><br><span class="line">3、启动docker：systemctl start docker</span><br><span class="line">4、停止docker：systemctl stop docker</span><br><span class="line">5、重启docker：systemctl restart docker</span><br><span class="line">6、查看docker状态：systemctl status docker</span><br><span class="line">7、开机启动：systemctl enable docker</span><br><span class="line">8、查看docker概要信息：docker info</span><br><span class="line">9、查看docker帮助文档：docker --help</span><br></pre></td></tr></table></figure><pre><code>systemctl命令是系统服务管理器指令，它是 service 和 chkconfig 两个命令组合</code></pre><h2 id="四、docker操作镜像"><a href="#四、docker操作镜像" class="headerlink" title="四、docker操作镜像"></a>四、docker操作镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、docker images #查看本机上所有的镜像文件</span><br><span class="line">    REPOSITORY：镜像所在的仓库名称</span><br><span class="line">TAG：镜像标签</span><br><span class="line">IMAGE ID：镜像ID</span><br><span class="line">CREATED：镜像的创建日期（不是获取该镜像的日期）</span><br><span class="line">SIZE：镜像大小</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2、docker search 镜像名称 #在注册中心(仓库)上进行搜索镜像</span><br><span class="line">NAME：仓库名称</span><br><span class="line">DESCRIPTION：镜像描述</span><br><span class="line">STARS：用户评价，反应一个镜像的受欢迎程度</span><br><span class="line">OFFICIAL：是否官方</span><br><span class="line">    AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">3、下载镜像:docker pull zookeeper</span><br><span class="line">   注意:默认是从官网下载</span><br><span class="line">可以ustc的docker镜像加速器速度很快。</span><br><span class="line">ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。</span><br><span class="line">(1)编辑该文件：vi /etc/docker/daemon.json  // 如果该文件不存在就手动创建；说明：在centos7.x下，通过vi。</span><br><span class="line">(2)在该文件中输入如下内容：</span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]</span><br><span class="line">&#125;</span><br><span class="line">(3)注意：一定要重启docker服务(systemctl restart docker.service)，如果重启docker后无法加速，可以重新启动OS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4、docker rmi $IMAGE_ID：删除指定镜像</span><br><span class="line">    docker rmi `docker images -q`：删除所有镜像</span><br><span class="line">    #$IMAGE_ID 镜像ID，通过docker images可以查看到镜像的ID</span><br></pre></td></tr></table></figure><h2 id="五、docker容器操作"><a href="#五、docker容器操作" class="headerlink" title="五、docker容器操作"></a>五、docker容器操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.查看容器操作:</span><br><span class="line">1)查看正在运行的容器:docker ps</span><br><span class="line">2)查看所有的容器（启动过的历史容器）:docker ps -a</span><br><span class="line">3)查看最后一次运行的容器：docker ps -l</span><br><span class="line">4)查看停止的容器：docker ps -f status=exited</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">2.创建与启动容器</span><br><span class="line">(1)创建容器需要的参数</span><br><span class="line">创建容器命令：docker run</span><br><span class="line">-i：表示运行容器</span><br><span class="line">-t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。</span><br><span class="line">--name :为创建的容器命名。比如:--name=mysqlcat</span><br><span class="line">-v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），</span><br><span class="line">      可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。</span><br><span class="line">-d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，</span><br><span class="line">      如果只加-i -t两个参数，创建后就会自动进去容器）。</span><br><span class="line">-p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个－p做多个端口映射</span><br><span class="line">(2)创建容器的两种方式:</span><br><span class="line">交互式容器：创建容器启动后会进入其命令行。</span><br><span class="line">docker -it --name=mycentos centos:7 /bin/bash</span><br><span class="line">说明:centos:7----可以使用docker images查看 7表示TAG：镜像标签 如果镜像名称为latest，就可以不用写</span><br><span class="line">/bin/bash表示linux的执行命令</span><br><span class="line">注意: 使用exit命令 退出当前容器，容器会关机</span><br><span class="line"></span><br><span class="line">守护式容器:类似于启动服务的进程一样，不会进入容器</span><br><span class="line">docker -di --name=mycentos2 centos:7</span><br><span class="line">进入容器:docke exec -it mycentos2 /bin/bash</span><br><span class="line">注意:使用exit命令，退出当前容器，但是容器不会关机</span><br><span class="line">(3)停止容器和启动容器</span><br><span class="line">停止容器:docker stop 容器的名称/容器的id</span><br><span class="line">启动容器:docker start 容器的名称/容器的id</span><br><span class="line">说明:容器的id可以通过docker ps -a 查看到，也就是:CONTAINER ID</span><br><span class="line"></span><br><span class="line">(4)删除容器</span><br><span class="line">    删除指定的容器：docker rm $CONTAINER_ID/NAME 注意:只能删除停掉的容器</span><br><span class="line">    删除所有容器：docker rm `docker ps -a -q`</span><br><span class="line"></span><br><span class="line">(5)文件拷贝(从宿主机拷贝到我们创建的容器)</span><br><span class="line">docker cp 需要拷贝的文件或者目录 容器名称:容器的目录</span><br><span class="line">注意:容器名称后面有冒号</span><br><span class="line"></span><br><span class="line">也可以将文件从容器内拷贝出来</span><br><span class="line">docker cp 容器名称:容器目录 需要拷贝的文件或目录</span><br><span class="line"></span><br><span class="line">(6)目录挂载</span><br><span class="line">    我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，</span><br><span class="line">这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。</span><br><span class="line">创建容器 添加-v参数 后边为   宿主机目录:容器目录</span><br><span class="line">docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos2 centos:7</span><br><span class="line">如果你共享的是多级的目录，可能会出现权限不足的提示。</span><br><span class="line">说明:容器里的目录可以不存在在进行映射的时候会自动创建。</span><br><span class="line"></span><br><span class="line">这是因为CentOS7中的安全模块selinux把权限禁掉了，</span><br><span class="line">我们在创建容器的时候需要添加参数  --privileged=true  来解决挂载的目录没有权限的问题</span><br><span class="line">docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos --privileged=true centos:7</span><br><span class="line"></span><br><span class="line">(7)查看容器IP地址</span><br><span class="line">    我们可以通过以下命令查看容器运行的各种数据</span><br><span class="line">docker inspect 容器的名称</span><br><span class="line"></span><br><span class="line">也可以直接执行下面的命令直接输出IP地址</span><br><span class="line">docker inspect --format=&apos;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&apos; mycentos2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5189695-0f77a07c50f709a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>docker基础架构</title>
    <link href="http://yoursite.com/2018/11/27/hello-world/"/>
    <id>http://yoursite.com/2018/11/27/hello-world/</id>
    <published>2018-11-27T06:24:04.054Z</published>
    <updated>2018-11-28T00:52:14.655Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/5189695-0f77a07c50f709a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p><h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="一、docker基础概念"><a href="#一、docker基础概念" class="headerlink" title="一、docker基础概念"></a>一、docker基础概念</h2><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的Linux机器上，也可以实现虚拟化，容器是完全使用沙箱机制，相互之间不会有任何接口。</p><h4 id="1、Docker有以下几个部分组成："><a href="#1、Docker有以下几个部分组成：" class="headerlink" title="1、Docker有以下几个部分组成："></a>1、Docker有以下几个部分组成：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- Client客户端</span><br><span class="line">- Docker Daemon守护进程</span><br><span class="line">- Docker Image镜像</span><br><span class="line">- DockerContainer容器</span><br><span class="line">- Registry镜像仓库</span><br></pre></td></tr></table></figure><h4 id="2、Docker的三大核心概念：镜像、容器、仓库"><a href="#2、Docker的三大核心概念：镜像、容器、仓库" class="headerlink" title="2、Docker的三大核心概念：镜像、容器、仓库"></a>2、Docker的三大核心概念：镜像、容器、仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 镜像：类似虚拟机的镜像、用俗话说就是安装文件。</span><br><span class="line">- 容器：类似一个轻量级的沙箱，容器是从镜像创建应用运行实例，</span><br><span class="line">-       可以将其启动、开始、停止、删除、而这些容器都是相互隔离、互不可见的。</span><br><span class="line">- 仓库：类似代码仓库，是Docker集中存放镜像文件的场所。</span><br></pre></td></tr></table></figure><p>Docker采用 C/S架构 Docker daemon 作为服务端接受来自客户的请求，<br>并处理这些请求（创建、运行、分发容器）。<br>客户端和服务端既可以运行在一个机器上，也可通过 socket 或者RESTful API 来进行通信。</p><h2 id="二-docker安装"><a href="#二-docker安装" class="headerlink" title="二.docker安装"></a>二.docker安装</h2><p>linux系统环境 ，同时需要注意Linux系统必须能够上网,虚拟机使用桥接模式<br>建议使用centos7版本安装docker，docker容器需要镜像文件容器与镜像文件的关系就类似于类与对象的关系。</p><h2 id="三-docker安装步骤"><a href="#三-docker安装步骤" class="headerlink" title="三.docker安装步骤"></a>三.docker安装步骤</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、使用yum命令在线安装:yum install docker</span><br><span class="line">2、查看docker的版本命令:docker -v</span><br><span class="line">3、启动docker：systemctl start docker</span><br><span class="line">4、停止docker：systemctl stop docker</span><br><span class="line">5、重启docker：systemctl restart docker</span><br><span class="line">6、查看docker状态：systemctl status docker</span><br><span class="line">7、开机启动：systemctl enable docker</span><br><span class="line">8、查看docker概要信息：docker info</span><br><span class="line">9、查看docker帮助文档：docker --help</span><br></pre></td></tr></table></figure><pre><code>systemctl命令是系统服务管理器指令，它是 service 和 chkconfig 两个命令组合</code></pre><h2 id="四、docker操作镜像"><a href="#四、docker操作镜像" class="headerlink" title="四、docker操作镜像"></a>四、docker操作镜像</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1、docker images #查看本机上所有的镜像文件</span><br><span class="line">    REPOSITORY：镜像所在的仓库名称</span><br><span class="line">TAG：镜像标签</span><br><span class="line">IMAGE ID：镜像ID</span><br><span class="line">CREATED：镜像的创建日期（不是获取该镜像的日期）</span><br><span class="line">SIZE：镜像大小</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2、docker search 镜像名称 #在注册中心(仓库)上进行搜索镜像</span><br><span class="line">NAME：仓库名称</span><br><span class="line">DESCRIPTION：镜像描述</span><br><span class="line">STARS：用户评价，反应一个镜像的受欢迎程度</span><br><span class="line">OFFICIAL：是否官方</span><br><span class="line">    AUTOMATED：自动构建，表示该镜像由Docker Hub自动构建流程创建的</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">3、下载镜像:docker pull zookeeper</span><br><span class="line">   注意:默认是从官网下载</span><br><span class="line">可以ustc的docker镜像加速器速度很快。</span><br><span class="line">ustc docker mirror的优势之一就是不需要注册，是真正的公共服务。</span><br><span class="line">(1)编辑该文件：vi /etc/docker/daemon.json  // 如果该文件不存在就手动创建；说明：在centos7.x下，通过vi。</span><br><span class="line">(2)在该文件中输入如下内容：</span><br><span class="line">&#123;</span><br><span class="line">&quot;registry-mirrors&quot;: [&quot;https://docker.mirrors.ustc.edu.cn&quot;]</span><br><span class="line">&#125;</span><br><span class="line">(3)注意：一定要重启docker服务(systemctl restart docker.service)，如果重启docker后无法加速，可以重新启动OS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">https://lug.ustc.edu.cn/wiki/mirrors/help/docker</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4、docker rmi $IMAGE_ID：删除指定镜像</span><br><span class="line">    docker rmi `docker images -q`：删除所有镜像</span><br><span class="line">    #$IMAGE_ID 镜像ID，通过docker images可以查看到镜像的ID</span><br></pre></td></tr></table></figure><h2 id="五、docker容器操作"><a href="#五、docker容器操作" class="headerlink" title="五、docker容器操作"></a>五、docker容器操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.查看容器操作:</span><br><span class="line">1)查看正在运行的容器:docker ps</span><br><span class="line">2)查看所有的容器（启动过的历史容器）:docker ps -a</span><br><span class="line">3)查看最后一次运行的容器：docker ps -l</span><br><span class="line">4)查看停止的容器：docker ps -f status=exited</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">2.创建与启动容器</span><br><span class="line">(1)创建容器需要的参数</span><br><span class="line">创建容器命令：docker run</span><br><span class="line">-i：表示运行容器</span><br><span class="line">-t：表示容器启动后会进入其命令行。加入这两个参数后，容器创建就能登录进去。即分配一个伪终端。</span><br><span class="line">--name :为创建的容器命名。比如:--name=mysqlcat</span><br><span class="line">-v：表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），</span><br><span class="line">      可以使用多个－v做多个目录或文件映射。注意：最好做目录映射，在宿主机上做修改，然后共享到容器上。</span><br><span class="line">-d：在run后面加上-d参数,则会创建一个守护式容器在后台运行（这样创建容器后不会自动登录容器，</span><br><span class="line">      如果只加-i -t两个参数，创建后就会自动进去容器）。</span><br><span class="line">-p：表示端口映射，前者是宿主机端口，后者是容器内的映射端口。可以使用多个－p做多个端口映射</span><br><span class="line">(2)创建容器的两种方式:</span><br><span class="line">交互式容器：创建容器启动后会进入其命令行。</span><br><span class="line">docker -it --name=mycentos centos:7 /bin/bash</span><br><span class="line">说明:centos:7----可以使用docker images查看 7表示TAG：镜像标签 如果镜像名称为latest，就可以不用写</span><br><span class="line">/bin/bash表示linux的执行命令</span><br><span class="line">注意: 使用exit命令 退出当前容器，容器会关机</span><br><span class="line"></span><br><span class="line">守护式容器:类似于启动服务的进程一样，不会进入容器</span><br><span class="line">docker -di --name=mycentos2 centos:7</span><br><span class="line">进入容器:docke exec -it mycentos2 /bin/bash</span><br><span class="line">注意:使用exit命令，退出当前容器，但是容器不会关机</span><br><span class="line">(3)停止容器和启动容器</span><br><span class="line">停止容器:docker stop 容器的名称/容器的id</span><br><span class="line">启动容器:docker start 容器的名称/容器的id</span><br><span class="line">说明:容器的id可以通过docker ps -a 查看到，也就是:CONTAINER ID</span><br><span class="line"></span><br><span class="line">(4)删除容器</span><br><span class="line">    删除指定的容器：docker rm $CONTAINER_ID/NAME 注意:只能删除停掉的容器</span><br><span class="line">    删除所有容器：docker rm `docker ps -a -q`</span><br><span class="line"></span><br><span class="line">(5)文件拷贝(从宿主机拷贝到我们创建的容器)</span><br><span class="line">docker cp 需要拷贝的文件或者目录 容器名称:容器的目录</span><br><span class="line">注意:容器名称后面有冒号</span><br><span class="line"></span><br><span class="line">也可以将文件从容器内拷贝出来</span><br><span class="line">docker cp 容器名称:容器目录 需要拷贝的文件或目录</span><br><span class="line"></span><br><span class="line">(6)目录挂载</span><br><span class="line">    我们可以在创建容器的时候，将宿主机的目录与容器内的目录进行映射，</span><br><span class="line">这样我们就可以通过修改宿主机某个目录的文件从而去影响容器。</span><br><span class="line">创建容器 添加-v参数 后边为   宿主机目录:容器目录</span><br><span class="line">docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos2 centos:7</span><br><span class="line">如果你共享的是多级的目录，可能会出现权限不足的提示。</span><br><span class="line">说明:容器里的目录可以不存在在进行映射的时候会自动创建。</span><br><span class="line"></span><br><span class="line">这是因为CentOS7中的安全模块selinux把权限禁掉了，</span><br><span class="line">我们在创建容器的时候需要添加参数  --privileged=true  来解决挂载的目录没有权限的问题</span><br><span class="line">docker run -di -v /usr/local/myhtml:/usr/local/myhtml --name=mycentos --privileged=true centos:7</span><br><span class="line"></span><br><span class="line">(7)查看容器IP地址</span><br><span class="line">    我们可以通过以下命令查看容器运行的各种数据</span><br><span class="line">docker inspect 容器的名称</span><br><span class="line"></span><br><span class="line">也可以直接执行下面的命令直接输出IP地址</span><br><span class="line">docker inspect --format=&apos;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&apos; mycentos2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/5189695-0f77a07c50f709a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;
      
    
    </summary>
    
    
  </entry>
  
</feed>
